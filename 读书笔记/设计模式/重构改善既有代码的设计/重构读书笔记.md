# 重构读书笔记
* 重构---在不改变程序外在行为的前提下改善内部代码结构
* 其实之前看过一遍，但是没有做笔记，第一遍看的时候也不觉得多么了不起，但是在现在的公司真的感觉到了绝望，再看一遍，突然发现里面很多真的很重要。
* 再看一遍前言就打动我了，现在公司的代码就是继承为核心体系，整个结构异常混乱，经常出现5级以上的继承关系，经常出现一些奇怪的bug，又很难定位，就算定位到问题的所在了，这么长的继承链，中间改一下，影响到多少个类，测试起来又很麻烦，其实以前也设计过baseViewController类型的基类，是否这种类型的设计在后续发展中很容易形成上述的这种问题，在越狱机上查看应用商店里的应用的时候也看到不少应用用了类似baseViewController的结构
* 还有一点是需要有覆盖的测试，但是对于客户端来说，UI上的覆盖测试手段好像比较匮乏，例如上面说到的这么复杂的继承关系，改了之后如何保证其他使用的页面没有问题，一个个手动去查看效率有些低

## 第一章 一个重构的例子
* 重构需要依赖于测试，先建立测试环境，以及可测试标准，保证功能
* 小步前进，并及时测试
* 绝大多数情况下，函数应该在它所使用的数据所属的对象内
* 减少临时变量，用查询方法替换临时变量
* 最好不要在另一个对象的属性基础上运用switch语句，如果不得不使用，也应该在对象自己的数据上使用
* 解决switch语句的方法，state模式，继承多态，将分支部分用多态描述

## 第二章 重构原则
### 两顶帽子
* 添加新功能 不应该修改已有代码，只添加功能
* 重构 不应该添加功能，只修改程序结构

### 为何重构
* 重构改进软件设计
* 重构使软件更容易理解
* 重构帮助找到Bug
* 重构提高编程速度
* 何时重构
* 三次法则 -- 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。

tips：

事不过三，三则重构。
> 添加新功能时重构
> 修补错误时重构
> 复审代码时重构

# 第三章 代码的坏味道
* duplicated code 重复代码
* long method 过长函数
* large class 过大的类
* long parmater list 过长参数列表
* divergent change 发散式变化（一个类受多种变化影响）
* shotgun surgery 散弹式修改 （一个变化影响多个类）
* feature envy 依恋情节 （方法依恋其他类的属性过多）
* data clumps 数据泥团 (不同的类中有相同字段，不同函数的方法签名相同，将相同的部分提炼到一个新对象)
* primitive obsession 基本类型偏执                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
* switch statements (switch 表达式)
* parallel inheritance hierarchies 平行继承体系 (为某个类增加子类，必须为另一个类增加相应子类)
* lazy class 冗余类
* speculative generality 夸夸其谈未来性
* Temporary field 令人迷惑的暂时字段 
* message chains 过度耦合的消息链 
* middle man 中间人
* inappropriate intimacy 押昵关系 （一个类需要过多的依赖父类或其他类的私有方法的实现）
* alternative class with different interfaces 异曲同工的类 （两个函数做同一件事，却有不同的签名）
* Incomplete library class 不完美的库类
* data class 纯稚的数据类
* refused beruest 被拒绝的遗赠 （子类继承父类用不到的方法）
* comments 过多注释

# 第四章 构筑测试体系
只需测试多数可能出错的情况，没必要测试所有情况
最近在重构某一个模块的时候认识到重构的时候每完成一小步进行测试真的是一件很重要的事情，这意味着你能快速的发现重构是否带来bug，比较让人沮丧的是某一些很古老，但是又不知道是什么作用的东西（是以路由或者其他弱耦合的方式供给其他模块使用），谁也说不清这是个什么东西，作用是什么，但是又能找到和他功能很相似的，是否能替换，说不清楚

# 第五章 重构列表
* 适用范围：单进程软件

# 第六章 重新组织函数
* extract method (提炼函数)
 * 过长函数需要注释 
* Inline method (内联函数)
 * 内部代码和名称一样清晰易读,直接在调用处是使用函数内容
* inline temp (内联临时变量) 
 * 影响到其他重构，用表达式直接替换临时变量的使用
* replace temp with query (以查询取代临时变量)
* Introduce explaining variable (引入解释性变量)
	* 用临时变量命名来解释复杂表达式  
* split temporary variable (分解临时变量)
	* 临时变量被赋于不同意义的值
* remove assignments to param eters(移除参数的赋值)
* replace method with method object (以函数对象取代函数)
	* 临时变量就变成了对象的实例 
* Substitute Algorithm (替换算法)

# 第7章 在对象之间搬移特性
* Move Method (搬移函数)
	* 如果一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合
	* 搬移函数之后目标函数获取源函数特性的方法：
		* 将这个特性也移到目标类
		* 建立或使用一个从目标类到源类的引用
		* 将源对象当做参数传给目标函数
		* 如果所需特性是变量，将他当做参数传给目标函数
* Move field (搬移字段)
* Extract Class (提炼类)
 * 某个类做了应该由两个类做的事
* Inline Class (类内联)
 * 某个类没有做太多的事情，将类的所有特性搬移到另一个类中，移除原类
* Hide Delegate (隐藏委托)
	* 客户通过委托类来调用另一个对象，在服务类上建立客户所需的函数，用以隐藏委托关系
* Remove Middle Man (移除中间人)
	* 某个类做了过多的简单委托动作
	* 让客户直接调用受托类
* Introduce Foreign Method (引入外加函数)
	* 你需要为提供服务的类增加一个函数，但你无法修改这个类
	* 在客户端中建立一个函数，并以第一参数形式传入一个服务类实例
* Introduce Local Extension (引入本地扩展)
	* 你需要为提供服务的类增加一个函数，但你无法修改这个类
	* 建立一个新类，包含需要添加的函数，使新类成为原类的子类或包装类
	
# 第8章 重新组织数据
* self encapsulate field (自封装字段)
* Replace Data Value with Object (以对象取代数据值)
	* 你有一个数据项，需要与其他数据和行为一起使用才有意义。
	* 思路：将数据项变成对象 
* change value to reference (将值对象改为引用对象)
	* 多个对象共享，则使用引用对象，减少对象间同步的成本
* change reference to value (将引用对象改为值对象)
	* 不可变对象
* replace array with object (以对象取代数组) 数组中的元素应该尽量是相似的东西
* Duplicate Observed Data (复制“被监视数据”) 数据居于视图中，将视图中的数据复制到controller中，用监听同步数据
* Change Unidirectional Associaltion to Bidirectional (将单向关联改为双向关联)
* Change Bidirectional Associaltion To Unidirectional (将双向关联改为单向关)
* Replace Magic Number with Symbolic Constant(以字面常量（宏定义，别名等）取代数值)
* Encapsulate Field（封装字段）
	* 数据私有，提供访问函数
* Encapsulate Collection（封装集合）
	* 让函数返回集合的只读副本，并在类内提供修改集合元素的方法
* Replace Record with Data Class (以数据类取代记录)
* Replace Type Code With Class (以类取代类型码)
	* 只是记录，不影响类功能，主要是编译器提供类型检测 
* Replace Type Code with Subclasses (以子类取代类型码)
	* 你有一个不可变的类型码，它会影响类的行为。 
* Replace Type Code with State/Stratey
	* 在对象生命周期内可变，（和上述以类取代类型码的区别是啥？state类中是对不同的子类型存在子类，工厂方法，方便多态处理？）
* Replace Subclass with Fields (以字段取代子类)
	* 你的各个子类的唯一差别只在“返回常量数据”的函数身上。
# 第9章 简化条件表达式
* Decompose Conditional (分解条件表达式)
	* 将条件语句的条件，执行部分拆分成多个函数 
* Consolidate Conditional Expression（合并条件表达式）
	* 有多个输出相同结构的条件，合并为同一个条件
* Consolidate Duplicate Conditional Fragments（合并重复的条件片段）
	* 不同的分支有相同的代码，把相同代码移动到条件之外
* Remove Control Flag（移除控制标记）
	* 在一系列布尔表达式中，某个变量带有“控制标记”(control flag) 的作用。以 break 语句或 return 语句取代控制标记。   
* 以卫语句取代嵌套条件表达式
	* 如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为“卫语句” (guard clauses)。
* Replace Condition with Polymorphism （以多态取代条件表达式）
	* 你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。  
* Introduce Null Object（引入Null对象）
	*  